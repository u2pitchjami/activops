import csv
import os
import shutil
import time
from datetime import datetime

from activops.android.process_android_datas import process_android_datas
from activops.db.db_connection import get_db_connection
from activops.utils.safe_runner import safe_main
from activops.utils.logger import LoggerProtocol, ensure_logger, with_child_logger, get_logger
from activops.utils.config import IMPORT_DIR

# Chemin dynamique bas√© sur le script en cours
script_dir = os.path.dirname(os.path.abspath(__file__))
logger = get_logger("android_import")

@with_child_logger
def get_machine_id(device_name: str, logger: LoggerProtocol | None = None) -> int | None:
    """
    R√©cup√®re le machine_id depuis la table machines en fonction du device_name.
    """
    logger = ensure_logger(logger, __name__)
    conn = get_db_connection(logger=logger)
    if not conn:
        return None

    cursor = conn.cursor()
    cursor.execute(
        "SELECT machine_id FROM machines WHERE machine_name = %s", (device_name,)
    )
    result = cursor.fetchone()

    machine_id = result[0] if result else None
    if machine_id:
        logger.info(f"[‚úÖ] Machine ID trouv√© pour {device_name} : {machine_id}")
    else:
        logger.info(f"[‚ùå] Machine {device_name} non trouv√©e en base !")

    cursor.close()
    conn.close()
    return machine_id

@with_child_logger
def process_log_file(file_path: str, logger: LoggerProtocol | None = None) -> None:
    """
    Traite un fichier de log et ins√®re les donn√©es dans la table temporaire.
    """
    logger = ensure_logger(logger, __name__)
    conn = get_db_connection(logger=logger)
    if not conn:
        return
    cursor = conn.cursor()

    with open(file_path, newline="", encoding="utf-8") as csvfile:
        reader = csv.DictReader(csvfile)
        first_row = next(reader, None)  # Lire la premi√®re ligne pour choper device_name

        if not first_row:
            logger.info(f"[‚ö†] Fichier vide, ignor√© : {file_path}")
            return

        device_name = first_row["device_name"]  # ‚úÖ R√©cup√©rer le device_name ici
        machine_id = get_machine_id(device_name)

        if not machine_id:
            logger.error(
                f"[‚ùå] Impossible de r√©cup√©rer machine_id pour {device_name}, fichier ignor√©."
            )
            return

        # Revenir au d√©but du fichier apr√®s la premi√®re ligne lue
        csvfile.seek(0)
        next(reader)  # Ignorer l'en-t√™te

        for row in reader:
            execution_timestamp = row["execution_timestamp"]
            package_name = row["package_name"]
            last_used = datetime.strptime(row["last_used"], "%Y-%m-%d %H:%M:%S")
            duration_seconds = int(row["duration_seconds"])

            try:
                cursor.execute(
                    """
                    INSERT INTO android_tmp (machine_id, execution_timestamp, package_name, last_used, duration_seconds)
                    VALUES (%s, %s, %s, %s, %s)
                """,
                    (
                        machine_id,
                        execution_timestamp,
                        package_name,
                        last_used,
                        duration_seconds,
                    ),
                )
                conn.commit()
                logger.info(
                    f"[‚úÖ] {device_name} | {package_name} ({duration_seconds}s) ins√©r√© dans android_tmp"
                )

            except Exception as e:
                logger.error(f"[‚ùå] Erreur MySQL : {e}")

    cursor.close()
    conn.close()

@safe_main
def scan_and_process_logs():
    """
    Scan le dossier de logs et traite tous les fichiers correspondant au pattern.
    """

    # 2Ô∏è‚É£ Sleep de 30 secondes pour √©viter le d√©calage avec Android
    logger.info("‚è≥ Pause de 30 secondes pour attendre la fin de l'envoi Android...")
    time.sleep(30)    

    print("[üìÇ] IMPORT_DIR", IMPORT_DIR)

    files = [
        f
        for f in os.listdir(IMPORT_DIR)
        if f.startswith("recap_android_") and f.endswith(".csv")
    ]
    if not files:
        logger.info("[üìÇ] Aucun fichier √† traiter.")
        return

    for file_name in sorted(
        files
    ):  # Trier par nom pour traiter dans l'ordre chronologique
        file_path = os.path.join(IMPORT_DIR, file_name)
        logger.info(f"[üîç] Traitement du fichier : {file_name}")
        file_date = datetime.now().strftime("%y%m%d")
        process_log_file(file_path=file_path, logger=logger)
        # Construire le chemin du dossier d‚Äôarchive
        archive_subdir = os.path.join(IMPORT_DIR, file_date)
        os.makedirs(archive_subdir, exist_ok=True)  # Cr√©er le dossier si n√©cessaire

        # Construire le chemin du fichier archiv√©
        archived_file_path = os.path.join(archive_subdir, f"{file_name}.processed")

        # D√©placer le fichier dans l'archive
        shutil.move(file_path, archived_file_path)
        logger.info(f"üìÇ Fichier archiv√© : {archived_file_path}")


if __name__ == "__main__":
    scan_and_process_logs()

    process_android_datas()
